My google search page 
====================== 
by Joan Alba Maldonado (joanalbamaldonadoNO_SPAM_PLEASE AT gmail DOT com, without NO_SPAM_PLEASE)


## General notes:
* I normally use BSD style for coding but I can adapt to other coding styles and guidelines.
* I decided to use both, functional and OOP mixed, just to show different code styles.
* Ugly design (I am not a good designer). But very easy to modify or add new CSS, HTML structure, etc. I just focused on the internal working aspect (mainly JavaScript).
* CSS used for wait/loading, showing errors (when fails loading an image, for instance), etc. should be improved with a less ugly design by CSS and maybe using animated images as loading spinners, etc. I just wanted to make it simple and working.
* Internally, I decided to perform two searches at the same time per search: one for images and the other one for web sites. Google gives often different results depending on the search type. This is a decision I made because I thought it was cool (at least not so common to see) to show two kind of results at the same time. But I could also have done it in a more traditional way: show just one search type and hide the other, letting the user to choose the desired one (as Google does).
* The Google Custom Search Engine I am using is free, which means you can only perform around 100 searches per day (in fact it is 50 since every search will perform two searches internally) before stopping to work. I could have created an array with different APIs and KEYs to choose in the case one fails to avoid this restriction. If you have a premium service, you can set your API and KEY in the config.js file to get rid of these and other restrictions.
* Sometimes I use id's instead of classes for performance reasons, but it would be easy to change. I also made other decisions focusing on performance (I got used to do this since 2006 when I started developing web-based games in JavaScript as a hobby and performance was important, specially for old browsers and slow hardware).
* The source code included in the "src" folder is just for development purposes. For deployment, all JS files should be in one single file, all compressed, etc. (look at the "dist" filder as an example).
* As an example (there are many ways to do it), I created a folder called "dist" which includes just a single compact "compressed" file (index.html, 17.4KB and only 7.24KB gzipped with level 9 compression) with the JS and CSS code inline, minified (and obfuscated). This way not only file size is reduced but it prevents doing more uncessary HTTP calls (important to keep server resources and often improve user experience). This is really important for web sites with heavy load and high concurrency that needs to serve several requests (thousands, could be even millions) per second. It is also important for servers that make you pay for bandwidth.
* In some parts, I reused different code I wrote before (some are from years ago), modifying them in the case I needed, to finish it faster and because that code has been tested and works.
* Unless I am wrong now, the unique code which is not mine is the function called indexOf (in others.js). This function provides support for Array.indexOf to browsers which do not support it. We do not need it if we do not want to support legacy browsers. I could have also coded it by myself since it is not difficult, but I decided to reuse this code.
* I am not using any library or framework. All is vanilla JavaScript coded in Notepad++ editor.
* All runs in "strict mode" without any issue.
* I could have done it better for sure but I did not have much free time and I wanted to finish it soon.


## Good/cool things:
* Compatible with almost all browsers with JavaScript and XHR (AJAX) support, modern and old ones (including Internet Explorer 6). Internet Explorer 5.5 is running all flawlessly but localization does not work so localized text is empty (it would not be difficult to solve but I do not think IE5.5 is worth it nowadays).
* Coded having in mind old legacy browsers (from IE6). The code could be optimized and would be much shorter and easier without this restriction but I decided to do it as a personal challenge. This is the reason I decided to use JavaScript and CSS code that runs virtually everywhere instead of using modern ES6 or similar which only runs in modern browsers. I usually do this with all my projects when possible because I think it is a very good thing that code runs in as many browsers as possible. When you have a web site/app/game which can have many users (for example in China, millions of users is not uncommon) you never know which one is a potential user/client (and even just 1% of millions of users is quite a lot of people).
* Code is easy to modify and configure. Main configuration and localization data in config.js.
* Support for history back and forward since is manipulates the hash. This part should be improved by also adding the language (not only the query string).
* Includes template code to add support for keyboard and devices compatible with keyboard events as TV remotes (Smart TV Alliance, Amazon Fire TV...) and console gamepad controls (Nintendo Wii/Wii U, Microsoft XBOX One, Sony Play Station 3/4, etc.). I decided not to give support for these controls (because almost all browsers from almost all devices already give support to jump to different links, buttons, inputs, etc.) and leave the template in the code just in case someone wants to change default's browser behaviour, improve user experience, etc. Without this template, code would be shorter.
* The web page can be accessed (from a link, for example) directly with URL/hash parameters (names can be modified easily in config.js) with a defined query search and language. The page will perform the desired search when loads. For example: http://address_to_this_page/?q=query_to_search&l=es (normally this feature is done server side but doing client side is cool and also gives you access to the hash)
* Added localization logic and support for both English and Spanish languages. It will try to detect automatically the user's language and choose the best one for each user. Every time the user changes the language, it will change the UI language on the fly and perform the active search again (if any) with the new language chosen. Adding new languages is easy by just modifying the config.js. Normally, localization logic is done server side but I think this way is cool and modern.
* Tries AJAX (XHR) calls first which are better than JSONP since it provides additional information and data as HTTP status, etc. and you do not need to relay on timeout workarounds normally (because server will normally respond a non-successful HTTP code when fails). If it fails, it will try to use JSONP fallback (this feature can be disabled in config.js). This JSONP fallback is important for different cases, as for example for some browsers (mainly not-so-new ones) which do not let you perform cross-domain requests with AJAX and do not support Access-Control-Allow-Origin header.
* All page is locked and shows loading screen (wait window) when it is loading to prevent users from trying to start using the web site when the JS code and DOM is still not ready. This is just a decision I took but can be changed easily.
* Some browsers as IE6 have problems using images through HTTPS by default. Some can also have problems with PNG images. Every image will try to load the thumbnail first which is normally smaller (provided by Google, normally in PNG format) and in the case it fails, it will try to load the original image (which is normally bigger and maybe it is not using PNG format or HTTPS protocol). If all fails, it will use CSS to show it (of course, CSS design should be improved, now is just a red background).


## Others:
* Empty results are considered a failed search just because I decided it this way. I could have improved UX by showing different messages in every case but I wanted to finish it soon since I do not think it is so important because. This code is just an example.
* There are no many errors to handle in such a simple app. But there is a function called errorHandler in main.js which can be modified to adapt the desired needs. The code uses this function just in the parts I considered really necessary but this could be changed easily if we wanted.
* Tested on desktop (Windows XP, Windows 10), mobile (Android, iOS) and tablet (Android, Windows 10) with many different browsers (some not common as Pale Moon, Vivaldi, etc.). All running well.